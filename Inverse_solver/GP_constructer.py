import numpy as np
from sklearn.gaussian_process.kernels import Matern
from numpy.random import default_rng
import matplotlib.pyplot as plt
import time
from scipy.linalg import cholesky

def generate_matern_kernel_constant_tensor(
    length_scale: float = 1.0,
    nu: float = 1.5,
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Generate the Matérn kernel for a Gaussian process under the assumption
    that epsilon is a 3x3 constant matrix with entries sampled from a GP(0, K).

    Parameters:
        length_scale (float): The length scale of the Matérn kernel (default: 1.0).
        nu (float): The smoothness parameter of the Matérn kernel (default: 1.5).
        random_state (int): Seed for random number generation (default: 42).

    Returns:
        tuple[np.ndarray, np.ndarray, np.ndarray]: A tuple (L, coords, K), where:
            - L is the Cholesky factor of the covariance matrix (K),
            - coords are the 2D grid coordinates used to evaluate the kernel,
            - K is the full covariance matrix generated by the kernel.
    """
    

    # Grid coordinates representing a 3x3 matrix entries (row, col indices)
    x = np.array([0, 1, 2])
    X, Y = np.meshgrid(x, x)
    coords = np.vstack([X.ravel(), Y.ravel()]).T  # shape: (9, 2)

    # Define Matérn kernel
    kernel = Matern(length_scale=length_scale, nu=nu)

    # Evaluate kernel on the 2D coordinate grid to produce a (9x9) covariance matrix
    K = kernel(coords)

    # Ensure numerical stability
    K += 1e-10 * np.eye(K.shape[0])

    # Compute the Cholesky decomposition
    L = cholesky(K, lower=True)

    return L, coords, K

def generate_samples(L: np.ndarray, num_samples: int, random_state: int = 42) -> np.ndarray:
    """
    Generate samples from a Gaussian process using the Cholesky factor L.

    Parameters:
        L (np.ndarray): Cholesky factor of the covariance matrix (shape: [9, 9]).
        num_samples (int): Number of 3x3 matrix samples to generate.
        random_state (int): Seed for reproducibility.

    Returns:
        np.ndarray: An array of shape (num_samples, 3, 3) with sampled 3x3 matrices.
    """
    rng = np.random.default_rng(random_state)
    Z = rng.standard_normal(size=(9, num_samples))  # shape: (9, num_samples)
    samples = L @ Z  # shape: (9, num_samples)
    return samples.T.reshape(num_samples, 3, 3)

L,_,K=generate_matern_kernel_constant_tensor()
epsilons=generate_samples(L,10)

plt.imshow(epsilons[0,:,:])
plt.show()